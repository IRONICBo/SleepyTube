# SleepyTube - Technical Design Document

## 1. System Architecture Overview

### 1.1 High-Level Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Chrome Extension                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │   Service    │  │   Content    │  │     UI       │     │
│  │   Worker     │  │   Script     │  │  Components  │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
│         │                  │                  │             │
│         └──────────────────┼──────────────────┘             │
│                            │                                │
│              ┌─────────────▼──────────────┐                │
│              │   WebAudio Processing      │                │
│              │        Engine              │                │
│              └─────────────┬──────────────┘                │
│                            │                                │
└────────────────────────────┼────────────────────────────────┘
                             │
                             ▼
                    ┌────────────────┐
                    │ YouTube Video  │
                    │  Audio Stream  │
                    └────────────────┘
```

### 1.2 Component Responsibilities

#### Service Worker (Background Script)
- **Role**: Extension lifecycle management, storage coordination
- **Responsibilities**:
  - Initialize extension on installation
  - Manage chrome.storage.sync for user preferences
  - Handle extension icon/badge updates
  - Coordinate between content scripts
  
#### Content Script
- **Role**: YouTube page injection and audio processing orchestration
- **Responsibilities**:
  - Detect YouTube video players
  - Inject UI components into YouTube DOM
  - Initialize and manage WebAudio pipeline
  - Handle user interactions from injected UI
  - Monitor video changes (navigation, playlist progression)
  - Calculate Sleep Scores

#### UI Components
- **Role**: User interface elements injected into YouTube
- **Responsibilities**:
  - Sleep Mode toggle button
  - Control panel overlay
  - Sleep Score badges
  - Settings interface
  - Real-time feedback indicators

#### WebAudio Processing Engine
- **Role**: Real-time audio signal processing
- **Responsibilities**:
  - Create and manage audio graph nodes
  - Apply compression, limiting, EQ filtering
  - Implement AGC (Auto Gain Control)
  - Perform real-time audio analysis
  - Calculate loudness and peak metrics

## 2. Technology Stack

### 2.1 Core Technologies
- **Chrome Extension**: Ma3
- **Audio Processing**: Web Audio API
- **Storage**: chrome.storage.sync API
- **UI Framework**: Vanilla JavaScript + Custom Web Components
- **Styling**: CSS3 with YouTube-matching design tokens

### 2.2 Key Web APIs Used
- `AudioContext`: Audio processing environment
- `createMediaElementSource()`: Capture YouTube video audio
- `DynamicsCompressorNode`: Volume compression
- `GainNode`: Volume control and makeup gain
- `BiquadFilterNode`: EQ filtering
- `AnalyserNode`: Real-time audio analysis
- `MutationObserver`: Detect YouTube DOM changes
- `chrome.storage.sync`: Persistent settings storage

## 3. WebAudio Processing Pipeline

### 3.1 Audio Graph Architecture

```
Video Element
      │
      ▼
┌────────────────────┐
│ MediaElementSource │
└────────┬───────────┘
         │
         ▼
┌────────────────────┐
│  Multiband Split   │  ← Voice Focus Feature
│  (3 bands)         │
└─┬──────┬────────┬──┘
  │      │        │
  │      │        │
 Low    Mid      High
  │      │        │
  ▼      ▼        ▼
┌────┐ ┌────┐ ┌────┐
│Gain│ │Gain│ │Gain│  ← Sidechain ducking (optional)
└─┬──┘ └─┬──┘ └─┬──┘
  │      │      │
  └──┬───┼───┬──┘
     │   │   │
     ▼   ▼   ▼
  ┌────────────┐
  │   Merger   │
  └─────┬──────┘
        │
        ▼
  ┌─────────────┐
  │ Compressor  │  ← Main dynamic range control
  └─────┬───────┘
        │
        ▼
  ┌─────────────┐
  │  Makeup     │  ← AGC + manual gain
  │  Gain Node  │─────┬───────┘
        │
        ▼
  ┌─────────────┐
  │  Limiter    │  ← Brickwall peak protection
  └─────┬───────┘
        │
        ▼
  ┌─────────────┐
  │ Destination │  ← Audio output
  └─────────────┘
```

### 3.2 Node Configuration Details

#### 3.2.1 Multiband Split (Voice Focus)
```javascript
// Low band: <250 Hz (bass, rumble)
const lowPassFilter = audioContext.createBiquadFilter();
lowPassFilter.type = 'lowpass';
lowPassFilter.frequency.value = 250;
lowPassFilter.Q.value = 0.707; // Butterworth response

// Mid band: 300 Hz - 3400 Hz (speech range)
const midBandpass1 = audioContext.createBiquadFilter();
midBandpass1.type = 'highpass';
midBandpass1.frequency.value = 300;

const midBandpass2 = audioContext.createBiquadFilter();
midBandpass2.type = 'lowpass';
midBandpass2.frequency.value = 3400;

// High band: >3400 Hz (sibilance, harshness)
const highPassFilter = audioContext.createBiquadFilter();
highPassFilter.type = 'highpass';
highPassFilter.frequency.value = 3400;
```

**Rationale**: 
- Speech intelligibility lives in 300-3400 Hz
- Separating bands allows independent processing
- Enables ducking background noise when speech detected

#### 3.2.2 Dynamic Range Compressor (Main)
```javascript
const compressor = audioContext.createDynamicsCompressor();

// Configurable by strength preset
const presets = {
  light: {
    threshold: -30,  // dB
    knee: 6,         // dB
    ratio: 3,        // 3:1
    attack: 0.006,   // 6ms
    release: 0.25    // 250ms
  },
  medium: {
    threshold: -24,
    knee: 6,
    ratio: 4,
    attack: 0.005,   // 5ms
    release: 0.15    // 150ms
  },
  strong: {
    threshold: -18,
    knee: 4,
    ratio: 6,
    attack: 0.003,   // 3ms
    release: 0.20    // 200ms
  }
};
```

**Behavior**:
- **Threshold**: Level above which compression starts
- **Knee**: Smoothness of compression curve transition
- **Ratio**: Amount of gain reduction (6:1 = strong compression)
- **Attack**: How fast compression engages (faster = more aggressive)
- **Release**: How fast compression disengages (slower = smoother)

#### 3.2.3 AGC (Auto Gain Control)
Implemented as a software control loop, not a hardware node:

```javascript
class AutoGainController {
  constructor(audioContext, makeupGainNode, analyserNode) {
    this.ac = audioContext;
    this.gainNode = makeupGainNode;
    this.analyser = analyserNode;
    
    this.targetLUFS = -18;  // Target loudness
    this.currentGainDb = 0;
    
    this.attackTimeMs = 80;   // Increase gain slowly
    this.releaseTimeMs = 250; // Decrease gain slowly
    
    this.buffer = new Float32Array(this.analyser.fftSize);
  }
  
  tick() {
    // Measure current loudness (simplified LUFS estimation)
    const currentDb = this.estimateLoudness();
    
    // Calculate needed gain adjustment
    const error = this.targetLUFS - currentDb;
    const limitedError = clamp(error, -18, +18);
    
    // Apply smoothing (attack/release)
    const alpha = this.calculateSmoothingFactor(limitedError);
    this.currentGainDb += (limitedError - this.currentGainDb) * alpha;
    
    // Update gain node
    const linearGain = dbToLinear(this.currentGainDb);
    this.gainNode.gain.setTargetAtTime(
      linearGain,
      this.ac.currentTime,
      0.05  // 50ms smoothing
    );
    
    requestAnimationFrame(() => this.tick());
  }
  
  estimateLoudness() {
    this.analyser.getFloatTimeDomainData(this.buffer);
    let sum = 0;
    for (let i = 0; i < this.buffer.length; i++) {
      sum += this.buffer[i] * this.buffer[i];
    }
    const rms = Math.sqrt(sum / this.buffer.length) + 1e-9;
    return 20 * Math.log10(rms);
  }
  
  calculateSmoothingFactor(error) {
    const timeConstant = (error > this.currentGainDb) 
      ? this.attackTimeMs 
      : this.releaseTimeMs;
    const samplesPerFrame = (this.ac.sampleRate / 60); // ~60 FPS
    return 1 - Math.exp(-1 / (samplesPerFrame * timeConstant / 1000));
  }
}
```

**Key Design Decisions**:
- **Asymmetric Response**: Slow gain increases (attack), faster decreases (release)
  - Prevents rapid pumping/breathing artifacts
  - Protects against sudden loud passages
- **Target LUFS**: -18 dBFS (similar to podcast/streaming standards)
- **Frame-based Update**: 60 Hz update rate via `requestAnimationFrame`

#### 3.2.4 Brickwall Limiter
```javascript
const limiter = audioContext.createDynamicsCompressor();
limiter.threshold.value = -1.0;  // Very close to 0 dBFS
limiter.knee.value = 0.0;        // Hard knee
limiter.ratio.value = 20.0;      // Near-infinite ratio
limiter.attack.value = 0.002;    // 2ms (very fast)
limiter.release.value = 0.05;    // 50ms
```

**Purpose**: 
- Absolute protection against clipping
- Catches transients that compressor misses
- Prevents ear damage from unexpected peaks

### 3.3 Sidechain Ducking Logic (Voice Focus)

```javascript
class VoiceFocusDucker {
  constructor(midGainNode, lowGainNode, highGainNode, analyser) {
    this.midAnalyser = analyser;
    this.lowGain = lowGainNode;
    this.highGain = highGainNode;
    
    this.duckAmountDb = 9;  // How much to reduce background
    this.buffer = new Float32Array(this.midAnalyser.fftSize);
  }
  
  tick(audioContext) {
    // Measure speech band energy
    const speechDb = this.estimateMidBandLevel();
    const speechLinear = Math.pow(10, speechDb / 20);
    
    // Detect speech presence (threshold-based)
    const speechPresence = clamp((speechLinear - 0.02) / 0.10, 0, 1);
    
    // Calculate duck amount (0 = no duck, 1 = full duck)
    const duckDb = this.duckAmountDb * speechPresence;
    const duckGain = Math.pow(10, -duckDb / 20);
    
    // Apply to low and high bands
    this.lowGain.gain.setTargetAtTime(duckGain, audioContext.currentTime, 0.05);
    this.highGain.gain.setTargetAtTime(duckGain, audioContext.currentTime, 0.05);
  }
  
  estimateMidBandLevel() {
    this.midAnalyser.getFloatTimeDomainData(this.buffer);
    let sum = 0;
    for (let i = 0; i < this.buffer.length; i++) {
      sum += this.buffer[i] * this.buffer[i];
    }
    const rms = Math.sqrt(sum / this.buffer.length) + 1e-9;
    return 20 * Math.log10(rms);
  }
}
```

**Effect**: When voice is detected, background music/noise is reduced by up to 9dB, improving speech clarity.

## 4. Sleep Score Calculation Algorithm

### 4.1 Scoring Factors

```javascript
class SleepScoreCalculator {
  constructor() {
    this.sampleDuration = 30; // Analyze first 30 seconds
  }
  
  async calculateScore(videoElement) {
    const audioContext = new OfflineAudioContext(
      1,  // mono
      this.sampleDuration * 48000,  // 48kHz sample rate
      48000
    );
    
    // Capture audio segment
    const source = audioContext.createMediaElementSource(videoElement);
    const analyser = audioContext.createAnalyser();
    analyser.fftSize = 2048;
    
    source.connect(analyser);
    analyser.connect(audioContext.destination);
    
    // Collect metrics
    const metrics = {
      peakDensity: this.analyzePeakDensity(analyser),
      loudnessRange: this.analyzeLoudnessRange(analyser),
      frequencyHarshness: this.analyzeFrequencyHarshness(analyser),
      speechRate: this.estimateSpeechRate(analyser)
    };
    
    // Calculate weighted score
    const score = this.computeWeightedScore(metrics);
    return {
      score: Math.round(score),
      breakdown: metrics,
      explanation: this.generateExplanation(metrics)
    };
  }
  
  analyzePeakDensity(analyser) {
    // Count sudden volume spikes above threshold
    const buffer = new Float32Array(analyser.fftSize);
    let peakCount = 0;
    let previousRms = 0;
    
    for (let frame = 0; frame < this.sampleDuration * 60; frame++) {
      analyser.getFloatTimeDomainData(buffer);
      const rms = this.calculateRMS(buffer);
      
      // Detect sudden increase (>6dB jump)
      if (rms > previousRms * 2.0) {
        peakCount++;
      }
      previousRms = rms;
    }
    
    // Normalize: 0 peaks = 100, 10+ peaks = 0
    const normalized = 100 - (peakCount * 10);
    return clamp(normalized, 0, 100);
  }
  
  analyzeLoudnessRange(analyser) {
    // Measure dynamic range (LRA approximation)
    const buffer = new Float32Array(analyser.fftSize);
    const loudnessHistory = [];
    
    for (let frame = 0; frame < this.sampleDuration * 60; frame++) {
      analyser.getFloatTimeDomainData(buffer);
      const db = 20 * Math.log10(this.calculateRMS(buffer) + 1e-9);
      loudnessHistory.push(db);
    }
    
    // Calculate 10th and 90th percentiles
    loudnessHistory.sort((a, b) => a - b);
    const p10 = loudnessHistory[Math.floor(loudnessHistory.length * 0.1)];
    const p90 = loudnessHistory[Math.floor(loudnessHistory.length * 0.9)];
    const lra = p90 - p10;
    
    // Normalize: 5 LU = 100, 20+ LU = 0
    const normalized = 100 - ((lra - 5) / 15) * 100;
    return clamp(normalized, 0, 100);
  }
  
  analyzeFrequencyHarshness(analyser) {
    // Measure energy in harsh frequency bands (8-12 kHz)
    const freqBuffer = new Float32Array(analyser.frequencyBinCount);
    const sampleRate = 48000;
    
    let harshEnergy = 0;
    let totalEnergy = 0;
    
    analyser.getFloatFrequencyData(freqBuffer);
    
    for (let i = 0; i < freqBuffer.length; i++) {
      const frequency = (i / freqBuffer.length) * (sampleRate / 2);
      const magnitude = Math.pow(10, freqBuffer[i] / 20);
      
      totalEnergy += magnitude;
      
      if (frequency >= 8000 && frequency <= 12000) {
        harshEnergy += magnitude;
      }
    }
    
    const harshRatio = harshEnergy / (totalEnergy + 1e-9);
    
    // Normalize: <5% harsh = 100, >20% harsh = 0
    const normalized = 100 - ((harshRatio - 0.05) / 0.15) * 100;
    return clamp(normalized, 0, 100);
  }
  
  estimateSpeechRate(analyser) {
    // Simplified zero-crossing rate analysis
    // Higher ZCR in mid-band ≈ faster speech
    const buffer = new Float32Array(analyser.fftSize);
    let zeroCrossings = 0;
    
    analyser.getFloatTimeDomainData(buffer);
    
    for (let i = 1; i < buffer.length; i++) {
      if ((buffer[i-1] >= 0 && buffer[i] < 0) || 
          (buffer[i-1] < 0 && buffer[i] >= 0)) {
        zeroCrossings++;
      }
    }
    
    const zcr = zeroCrossings / buffer.length;
    
    // Normalize: low ZCR = slow speech = 100, high ZCR = fast = 0
    const normalized = 100 - (zcr / 0.1) * 100;
    return clamp(normalized, 0, 100);
  }
  
  computeWeightedScore(metrics) {
    return (
      metrics.peakDensity * 0.40 +
      metrics.loudnessRange * 0.30 +
      metrics.frequencyHarshness * 0.20 +
      metrics.speechRate * 0.10
    );
  }
  
  generateExplanation(metrics) {
    const issues = [];
    
    if (metrics.peakDensity < 70) {
      issues.push('High peak density: Sudden sounds detected');
    }
    if (metrics.loudnessRange < 70) {
      issues.push('Wide volume range: Inconsistent loudness');
    }
    if (metrics.frequencyHarshness < 70) {
      issues.push('Harsh frequencies: Stimulating high tones');
    }
    if (metrics.speechRate < 70) {
      issues.push('Fast speech rate: High information density');
    }
    
    if (issues.length === 0) {
      return 'Excellent sleep characteristics';
    }
    
    return issues.join(' • ');
  }
  
  calculateRMS(buffer) {
    let sum = 0;
    for (let i = 0; i < buffer.length; i++) {
      sum += buffer[i] * buffer[i];
    }
    return Math.sqrt(sum / buffer.length);
  }
}
```

### 4.2 Score Caching Strategy

```javascript
class ScoreCache {
  constructor() {
    this.cache = new Map(); // videoId -> {score, timestamp}
    this.maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days
  }
  
  async get(videoId) {
    const cached = this.cache.get(videoId);
    
    if (!cached) return null;
    
    // Check if cache is stale
    if (Date.now() - cached.timestamp > this.maxAge) {
      this.cache.delete(videoId);
      return null;
    }
    
    return cached.score;
  }
  
  set(videoId, score) {
    this.cache.set(videoId, {
      score,
      timestamp: Date.now()
    });
    
    // Persist to chrome.storage
    this.persist();
  }
  
  async persist() {
    const data = Object.fromEntries(this.cache);
    await chrome.storage.local.set({ scoreCache: data });
  }
  
  async load() {
    const { scoreCache } = await chrome.storage.local.get('scoreCache');
    if (scoreCache) {
      this.cache = new Map(Object.entries(scoreCache));
    }
  }
}
```

## 5. Extension Architecture Details

### 5.1 Manifest V3 Configuration

```json
{
  "manifest_version": 3,
  "name": "SleepyTube - YouTube Sleep Mode",
  "version": "1.0.0",
  "description": "Transform YouTube into a sleep-safe audio experience with intelligent volume stabilization and frequency optimization.",
  
  "icons": {
    "16": "icons/icon16.png",
    "32": "icons/icon32.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  },
  
  "action": {
    "default_popup": "popup/popup.html",
    "default_icon": {
      "16": "icons/icon16.png",
      "32": "icons/icon32.png"
    }
  },
  
  "background": {
    "service_worker": "background/service-worker.js"
  },
  
  "content_scripts": [
    {
      "matches": ["*://*.youtube.com/*"],
      "js": [
        "content/utils.js",
        "content/audio-engine.js",
        "content/ui-components.js",
        "content/sleep-score.js",
        "content/main.js"
      ],
      "css": ["content/styles.css"],
      "run_at": "document_end"
    }
  ],
  
  "permissions": [
    "storage"
  ],
  
  "host_permissions": [
    "*://*.youtube.com/*"
  ],
  
  "web_accessible_resources": [
    {
      "resources": ["icons/*", "assets/*"],
      "matches": ["*://*.youtube.com/*"]
    }
  ]
}
```

### 5.2 File Structure

```
sleepytube/
├── manifest.json
├── background/
│   └── service-worker.js       # Extension lifecycle management
├── content/
│   ├── main.js                 # Entry point, orchestration
│   ├── audio-engine.js         # WebAudio pipeline
│   ├── ui-components.js        # Sleep mode button, panel
│   ├── sleep-score.js          # Score calculation
│   ├── utils.js                # Helper functions
│   └── styles.css              # YouTube-matching styles
├── popup/
│   ├── popup.html              # Extension popup UI
│   ├── popup.js                # Popup logic
│   └── popup.css               # Popup styling
├── icons/
│   ├── icon16.png
│   ├── icon32.png
│   ├── icon48.png
│   └── icon128.png
├── assets/
│   └── sleep-icon.svg          # Sleep mode SVG icon
└── README.md
```

### 5.3 YouTube Page Detection & Injection

```javascript
// content/main.js
class SleepyTubeController {
  constructor() {
    this.currentVideo = null;
    this.audioEngine = null;
    this.uiManager = null;
    
    this.init();
  }
  
  init() {
    // Wait for YouTube to load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => this.boot());
    } else {
      this.boot();
    }
    
    // Handle YouTube SPA navigation
    document.addEventListener('yt-navigate-finish', () => this.handleNavigation());
    
    // Observe DOM changes for video element
    this.observeVideoChanges();
  }
  
  boot() {
    const pageType = this.detectPageType();
    
    if (pageType === 'watch' || pageType === 'shorts') {
      this.initializeWatchPage();
    } else if (pageType === 'home' || pageType === 'search') {
      this.initializeBrowsePage();
    }
  }
  
  detectPageType() {
    const path = window.location.pathname;
    
    if (path.startsWith('/watch')) return 'watch';
    if (path.startsWith('/shorts/')) return 'shorts';
    if (path === '/' || path === '/feed/subscriptions') return 'home';
    if (path.startsWith('/results')) return 'search';
    
    return 'other';
  }
  
  initializeWatchPage() {
    // Find video element
    const video = this.findVideoElement();
    if (!video) {
      console.warn('[SleepyTube] Video element not found, retrying...');
      setTimeout(() => this.initializeWatchPage(), 500);
      return;
    }
    
    // Initialize audio processing
    this.audioEngine = new AudioEngine(video);
    
    // Inject UI controls
    this.uiManager = new UIManager(this.audioEngine);
    this.uiManager.injectSleepModeButton();
    
    this.currentVideo = video;
  }
  
  initializeBrowsePage() {
    // Inject Sleep Score badges on thumbnails
    this.uiManager = new UIManager(null);
    this.uiManager.injectSleepScoreBadges();
  }
  
  findVideoElement() {
    // Standard watch page
    let video = document.querySelector('.html5-video-player > video.html5-main-video');
    
    // Shorts page
    if (!video) {
      video = document.querySelector('ytd-reel-video-renderer[is-active] video');
    }
    
    return video;
  }
  
  observeVideoChanges() {
    const observer = new MutationObserver((mutations) => {
      const newVideo = this.findVideoElement();
      
      if (newVideo && newVideo !== this.currentVideo) {
        console.log('[SleepyTube] Video changed, reinitializing...');
        this.handleVideoChange(newVideo);
      }
    });
    
    observer.observe(document.documentElement, {
      childList: true,
      subtree: true
    });
  }
  
  handleVideoChange(newVideo) {
    // Cleanup old audio engine
    if (this.audioEngine) {
      this.audioEngine.disconnect();
    }
    
    // Initialize with new video
    this.audioEngine = new AudioEngine(newVideo);
    this.uiManager.updateAudioEngine(this.audioEngine);
    
    this.currentVideo = newVideo;
  }
  
  handleNavigation() {
    // YouTube SPA navigation detected
    this.boot();
  }
}

// Initialize on page load
const sleepyTube = new SleepyTubeController();
```

## 6. Data Storage Schema

### 6.1 User Preferences (chrome.storage.sync)

```javascript
const DEFAULT_CONFIG = {
  // Sleep Mode state
  sleepModeEnabled: false,
  
  // Audio processing settings
  compressionStrength: 'medium',  // 'light' | 'medium' | 'strong'
  targetLoudness: -18,            // LUFS target
  outputGain: 0,                  // Manual gain adjustment (dB)
  
  // EQ settings
  eqPreset: 'gentle',            // 'natural' | 'gentle' | 'ultra-soft'
  voiceFocusEnabled: true,
  duckingAmount: 9,              // dB (0-12)
  
  // Advanced settings
  autoGainEnabled: true,
  limiterEnabled: true,
  
  // Auto-fade settings
  autoFadeEnabled: false,
  fadeDelayMinutes: 15,
  fadeAmountPercent: 20,
  
  // UI preferences
  showSleepScores: true,
  autoEnableSleepMode: false,    // Auto-enable for low-scored videos
  
  // Calibration data
  calibrationCompleted: false,
  calibrationProfile: null
};
```

### 6.2 Sleep Score Cache (chrome.storage.local)

```javascript
// Structure
{
  scoreCache: {
    'videoId1': {
      score: 85,
      breakdown: {
        peakDensity: 90,
        loudnessRange: 85,
        frequencyHarshness: 80,
        speechRate: 85
      },
      timestamp: 1644123456789,
      explanation: 'Excellent sleep characteristics'
    },
    'videoId2': { /* ... */ }
  }
}
```

## 7. Performance Optimizations

### 7.1 Audio Processing Efficiency
- **Reuse AudioContext**: Single context per tab (not per video)
- **Node Pooling**: Reuse filter nodes when video changes
- **Lazy Initialization**: Only create audio graph when Sleep Mode enabled
- **Bypass Mode**: Direct connection when disabled (zero overhead)

### 7.2 Sleep Score Calculation
- **Background Computation**: Use `requestIdleCallback` for score calculation
- **Progressive Analysis**: Calculate score in chunks to avoid blocking
- **Caching**: Store scores in localStorage, invalidate after 7 days
- **Lazy Loading**: Only calculate scores for visible thumbnails

### 7.3 UI Rendering
- **Virtual Scrolling**: Only render visible score badges
- **Debounced Updates**: Throttle AGC display updates to 2 Hz
- **CSS Containment**: Isolate badge rendering with `contain: layout paint`

## 8. Browser Compatibility & Fallbacks

### 8.1 Supported Browsers
- Chrome 90+ (primary target)
- Edge 90+ (Chromium-based)
- Opera 76+ (Chromium-based)

### 8.2 Feature Detection
```javascript
function checkAudioSupport() {
  const checks = {
    audioContext: !!(window.AudioContext || window.webkitAudioContext),
    mediaElementSource: 'createMediaElementSource' in AudioContext.prototype,
    dynamicsCompressor: 'createDynamicsCompressor' in AudioContext.prototype,
    biquadFilter: 'createBiquadFilter' in AudioContext.prototype
  };
  
  const unsupported = Object.keys(checks).filter(key => !checks[key]);
  
  if (unsupported.length > 0) {
    console.error('[SleepyTube] Unsupported features:', unsupported);
    return false;
  }
  
  return true;
}
```

## 9. Security & Privacy Considerations

### 9.1 Content Security Policy
- No external script loading
- No eval() or unsafe-inline
- All resources bundled with extension

### 9.2 Data Privacy
- **Zero Telemetry**: No user data sent to external servers
- **Local Processing**: All audio analysis done in-browser
- **No Recording**: Never store or transmit audio streams
- **Minimal Permissions**: Only `storage` and YouTube host permissions

### 9.3 YouTube Terms of Service Compliance
- No video downloading
- No content scraping
- No API abuse
- Only client-side audio processing of already-playing content

## 10. Testing Strategy

### 10.1 Unit Testing
- Audio calculation functions (dB conversion, RMS, etc.)
- Sleep Score algorithm components
- Configuration management

### 10.2 Integration Testing
- Audio graph node connections
- Storage sync behavior
- UI injection across page types

### 10.3 Manual Testing Scenarios
1. **Watch page**: Standard video playback
2. **Shorts**: Vertical video format
3. **Playlist**: Auto-play transitions
4. **Live streams**: Real-time audio
5. **Ads**: Volume normalization during ads
6. **Background tab**: Audio continues when tab inactive

## 11. Future Technical Enhancements

### 11.1 Machine Learning Integration
- **Event Detection**: TensorFlow.js model for laughter/applause/music detection
- **Model**: Pre-trained AudioSet classifier (lightweight)
- **Inference**: WebAssembly for performance

### 11.2 Advanced Audio Analysis
- **True LUFS**: Implement ITU-R BS.1770-4 standard
- **Spectral Analysis**: More sophisticated frequency profiling
- **Speech Detection**: VAD (Voice Activity Detection)

### 11.3 Cross-Platform Sync
- Sync settings across devices via Google account
- Cloud-based score database (optional, opt-in)

---

**Document Version**: 1.0  
**Last Updated**: 2026-02-06  
**Author**: SleepyTube Engineering Team
